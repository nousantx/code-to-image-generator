<!doctype html>
<html
  lang="en"
  child="
(body): family-sans-serif w-mx-800px mx-auto p-20px;
(textarea): w-100% h-200px mb-10px;
(.btn): [all]-unset mr-10px h-40px d-inline-flex ai-center px-12px [cursor]-pointer  bg-#1c1c1c text-white br-8px fs-14px fw-500;
(canvas): [border]-[2px_solid_#ccc] mt-1rem;
(#error): text-red mt-10px;
(select, input): h-40px px-12px br-8px border-[1px_solid_#ccc] mr-10px;
(.config-row): d-flex ai-center mb-10px;
"
>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTML to Image Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/@tenoxui/core@1.3.0-alpha.3/dist/tenoxui-full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tenoxui/property@1.4.5"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,100..900;1,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
      rel="stylesheet"
      id="google-fonts"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Inter, system-ui, -apple-system, sans-serif;
      }
    </style>
  </head>
  <body>
    <h1>HTML to Image Generator</h1>
    <h1 class="fs-5rem fw-700 text-black">Hello</h1>
    <textarea class="my-2rem" id="htmlInput">
<div class="w-1000px h-1000px d-flex ai-center jc-center" style="font-family: Poppins, system-ui, -apple-system, sans-serif;">
  <div class="bg-blue fw-700 box-300px text-white p-2rem fs-5rem br-1rem">
    Hello <span class="bg-yellow text-black [filter]-[blur(10px)]">Tenox!</span>
  </div>
</div>
    </textarea>
    <br />
    <div class="config-row">
      <select id="outputFormat">
        <option value="png">PNG</option>
        <option value="jpeg">JPEG</option>
        <option value="webp">WebP</option>
        <option value="svg">SVG</option>
      </select>
      <input type="number" id="scale" min="1" max="4" step="0.1" value="1" />
      <label for="scale">Scale Factor</label>
    </div>
    <button class="btn" onclick="generateImage()">Generate Image</button>
    <button class="btn" onclick="downloadImage()">Download Image</button>
    <div id="error"></div>
    <canvas id="canvas" width="1000" height="1000"></canvas>
    <script>
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')
      const errorDiv = document.getElementById('error')
      const outputFormatSelect = document.getElementById('outputFormat')
      const scaleInput = document.getElementById('scale')

      const tenoxuiConfig = {
        property: TENOXUI_PROPERTY.property,
        values: { full: '100%' },
        attributify: true
      }

      const selector = '*'
      document.querySelectorAll(selector).forEach(element => {
        new __tenoxui_core.MakeTenoxUI({ element, ...tenoxuiConfig }).useDOM()
      })

      // Function to fetch and process Google Fonts stylesheet
      async function getGoogleFontsStyles() {
        const googleFontsLink = document.getElementById('google-fonts')
        if (!googleFontsLink) return ''

        try {
          // Fetch the stylesheet content
          const response = await fetch(googleFontsLink.href)
          const css = await response.text()

          // Extract and process all @font-face rules
          const fontFaceRules = []
          const fontFaceRegex = /@font-face\s*{[^}]+}/g
          const matches = css.match(fontFaceRegex)

          if (matches) {
            for (const rule of matches) {
              // Extract the URL from the font-face rule
              const urlMatch = rule.match(/url\(([^)]+)\)/)
              if (urlMatch) {
                let fontUrl = urlMatch[1].replace(/['\"]/g, '')
                try {
                  // Fetch the font file and convert to base64
                  const fontResponse = await fetch(fontUrl)
                  const fontBuffer = await fontResponse.arrayBuffer()
                  const base64Font = btoa(String.fromCharCode(...new Uint8Array(fontBuffer)))
                  
                  // Determine font format
                  const fontFormat = fontUrl.endsWith('woff2') ? 'woff2' : 
                                   fontUrl.endsWith('woff') ? 'woff' : 
                                   fontUrl.endsWith('ttf') ? 'truetype' : 'opentype'

                  // Replace the URL with base64 data
                  const processedRule = rule.replace(
                    /url\([^)]+\)/,
                    `url(data:application/font-${fontFormat};charset=utf-8;base64,${base64Font})`
                  )
                  fontFaceRules.push(processedRule)
                } catch (error) {
                  console.warn('Failed to fetch font:', fontUrl, error)
                  fontFaceRules.push(rule) // Keep original rule as fallback
                }
              }
            }
          }

          return fontFaceRules.join('\n')
        } catch (error) {
          console.error('Failed to process Google Fonts:', error)
          return ''
        }
      }

      async function generateSVG() {
        const temp = document.createElement('div')
        temp.innerHTML = document.getElementById('htmlInput').value
        temp.querySelectorAll('*').forEach(element => {
          new __tenoxui_core.MakeTenoxUI({ element, ...tenoxuiConfig }).useDOM()
        })
        
        const scale = parseFloat(scaleInput.value)
        const scaledWidth = canvas.width * scale
        const scaledHeight = canvas.height * scale

        // Get processed font-face rules
        const fontFaceRules = await getGoogleFontsStyles()
        
        const removeAttributesAndElements = element => {
          if (element.tagName.toLowerCase() !== 'style') {
            Array.from(element.attributes).forEach(attr => {
              if (attr.name !== 'style') {
                element.removeAttribute(attr.name)
              }
            })
            Array.from(element.children).forEach(child => {
              if (child.tagName.toLowerCase() !== 'style') {
                removeAttributesAndElements(child)
              }
            })
          }
        }
        removeAttributesAndElements(temp)

        return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" width="${scaledWidth}" height="${scaledHeight}">
  <defs>
    <style type="text/css">
      ${fontFaceRules}
    </style>
  </defs>
  <foreignObject width="100%" height="100%">
    <div xmlns="http://www.w3.org/1999/xhtml">
      ${temp.innerHTML}
    </div>
  </foreignObject>
</svg>`
      }

      async function generateImage() {
        const scale = parseFloat(scaleInput.value)
        const scaledWidth = canvas.width * scale
        const scaledHeight = canvas.height * scale

        errorDiv.textContent = ''
        canvas.width = scaledWidth
        canvas.height = scaledHeight
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        try {
          const svgData = await generateSVG()
          const img = new Image()
          img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData)
          
          await new Promise((resolve, reject) => {
            img.onload = resolve
            img.onerror = reject
          })

          ctx.scale(scale, scale)
          ctx.drawImage(img, 0, 0)
        } catch (error) {
          errorDiv.textContent = 'Failed to generate image: ' + error.message
        }
      }

      async function downloadImage() {
        try {
          const outputFormat = outputFormatSelect.value
          const link = document.createElement('a')
          link.download = `generated-image.${outputFormat}`

          if (outputFormat === 'svg') {
            const svgData = await generateSVG()
            const blob = new Blob([svgData], { type: 'image/svg+xml' })
            link.href = URL.createObjectURL(blob)
          } else {
            link.href = canvas.toDataURL(`image/${outputFormat}`)
          }

          link.click()

          if (outputFormat === 'svg') {
            URL.revokeObjectURL(link.href)
          }
        } catch (error) {
          errorDiv.textContent = 'Failed to download image: ' + error.message
        }
      }

      generateImage()
    </script>
  </body>
</html>